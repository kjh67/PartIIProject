import pygame
import numpy as np
import argparse

from OpenGL.GL import glWindowPos2d, glDrawPixels
from OpenGL.GL import GL_RGBA, GL_UNSIGNED_BYTE, GL_CONTEXT_FLAG_DEBUG_BIT_KHR
from threading import Thread, Event as ThreadEvent

from renderer.gauss_renderer import GaussianRenderer
from renderer.point_renderer import PointRenderer
from game.cameras import PlayerCamera, DevCamera


def mainloop(filename, colmap_path=None, points=False, devcam=False, screensize=(800,600)):

    # Pygame and OpenGL canvas setup
    pygame.init()
    pygame.display.gl_set_attribute(GL_CONTEXT_FLAG_DEBUG_BIT_KHR, True)
    pyg_screen = pygame.display.set_mode(screensize, pygame.OPENGL)
    pygame.display.set_caption("Splatting viewer")

    # Initialising FPS display font
    display_font = pygame.font.SysFont("", 25)
    display_fps = False

    # Instantiate player camera, which will handle all movement and model/view matrices
    if devcam:
        camera = DevCamera()
    else:
        camera = PlayerCamera(colmap_path=colmap_path)

    # Initialise renderer
    if not points:
        renderer = GaussianRenderer(filename, *screensize)
    else:
        renderer = PointRenderer(filename, *screensize)

    # set up gaussian sorting in the background - use event to signal to the main loop when a sort has been completed
    gaussians_updated = ThreadEvent()
    gaussians_updated.clear()
    def sorting_loop(gaussians_updated):
        while True:
            renderer.sort_gaussians()
            gaussians_updated.set()
    sorter = Thread(target=sorting_loop, args=[gaussians_updated], daemon=True)

    # Set up clock for movement and fps calculations
    fps_clock = pygame.time.Clock()
    fps_clock.tick()

    # Start the sorting thread before entering main game loop
    sorter.start()

    while True:
        # Check for a completed Gaussian sort, and update renderer state if necessary
        if gaussians_updated.is_set():
            renderer.update_buffered_state()
            gaussians_updated.clear()

        renderer.update_modelview(camera.get_modelview())
        renderer.render()

        # Draw FPS counter on the screen
        if display_fps:
            text_surface = display_font.render(f"{str(fps_clock.get_fps())[:5]}", False, (255,255,255,255), (0,0,0, 255))
            text_data = pygame.image.tostring(text_surface, "RGBA", True)
            glWindowPos2d(0, 0)
            glDrawPixels(text_surface.get_width(), text_surface.get_height(), GL_RGBA, GL_UNSIGNED_BYTE, text_data)

        # switch double buffered displays
        pygame.display.flip()

        # calculate time since last frame
        t_delta = fps_clock.tick()
        
        # Deal with user input for game settings, quitting etc
        keyspressed = pygame.key.get_pressed()
        for event in pygame.event.get():
            if event.type == pygame.QUIT or (event.type == pygame.KEYDOWN and event.key == pygame.K_x):
                pygame.quit()
                quit()

            elif (event.type == pygame.KEYDOWN and event.key == pygame.K_f):
                display_fps = not display_fps

            elif (event.type == pygame.KEYDOWN and event.key == pygame.K_0):
                renderer.save_frame("./TESTIMAGE.jpg")

        # Update camera model/view matrix using user input
        camera.update(keyspressed, t_delta)


if __name__ == "__main__":
    parser = argparse.ArgumentParser("Game allowing exploration of the scene ")
    parser.add_argument('render_source', type=str, help="Path to .ply file containing gaussian splat model")
    parser.add_argument('-c', '--colmap_cams_path', type=str, help="Optional path to cameras.bin generated by COLMAP; requied for correct movement behaviour", default=None)
    parser.add_argument('-p', '--points', action='store_true', help="Render Gaussians as points rather than full splats")
    parser.add_argument('--devcam', action='store_true', help="Activates development camera settings; camera movement will not be constrained to the street plane")

    args = parser.parse_args()
    mainloop(args.render_source, args.colmap_cams_path, args.points, args.devcam)
